# -*- coding: utf-8 -*-
"""Primes project.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1G1HIEpO3h9OeVrTMtdXgTa20YFc_DG3t

Prime project
"""

import math   # for sqrt and other math functions
import time   # for runtime analysis
import matplotlib.pyplot as plt  # for plotting

"""# Prime project Part 1

In this part of the project we are going to implement the Seive of Sundaram and comapre it with the Sieve of Eratosthenes.
 To do:


1.  Make sure that the implementation works.
2.  Compare the run time of both methods.
3. Plot that shows the results (n on the horizontal axis, runtimes on the vertical axis)


"""

#Fast Eratosthenes
# returns a list of primes from 1 to n
def fastEratos(n):
  # create a list of numbers 2, 3, 4, ..., nMax
  nums = list(range(2, n + 1))

  # compute sqrt(n)
  nroot = math.sqrt(n)

  # loop over each number less than or equal to sqrt(n)
  i = 0
  while nums[i] <= nroot:
    # if number is prime, then set all of its multiples to zero
    if nums[i] > 0:
      # then nums[i] is prime
      j = i + nums[i] # current index plus the current prime
      while j < len(nums):
        nums[j] = 0    # "cross off" this multiple of the current prime
        j += nums[i]   # go to the next multiple of the current prime

    # now move to the next prime in the list
    i += 1

  # now return all numbers that are still nonzero
  primes = [p for p in nums if p != 0]

  return primes

print(fastEratos(100))

"""From the above computation we can see the first 100 prime numbers, thus our implementation for Sieve of Eratosthenes is working. This version avoids deleting numbers from lists, as well as checking for divisibility using if and modulus operators.  

Now let us move to run time computation.
"""

def timeEratos(n):
  startTime = time.time()
  fastEratos(n)
  endTime = time.time()
  return endTime - startTime

nMaxVals = range(10,10000,10)
runtimes = [timeEratos(n) for n in nMaxVals]
print(runtimes)

plt.plot(nMaxVals, runtimes, 'go')
plt.title("Sieve of Eratosthenes runtimes")
plt.xlabel("nMax")
plt.ylabel("time (seconds)");

"""From our run time plot we can see that as we increase the range of n the run time increases. What about Seive of Sundaram."""

def SieveOfSundaram(p):
  n = int((p-1)/2)
  nums = [0]*(n+1)

  for i in range(1, n+1):
    j = i
    while i+j+2*i*j <= n:
      nums[1+j+2*i*j] = 1
      j += 1

  primeList = [2]
  for i in range(1, n+1):
    if nums[i] == 0:
      primeList.append(2*i+1)
  return primeList

print(SieveOfSundaram(100))

def timesundaram(n):
  startTime1 = time.time()
  SieveOfSundaram(n)
  endTime1 = time.time()
  return endTime1 - startTime1

nMaxVals1 = range(10,10000,10)
runtimes1 = [timesundaram(n) for n in nMaxVals1]
print(runtimes1)

plt.plot(nMaxVals1, runtimes1, 'go') # creates the plot; syntax is plot(xvals, yvals, format)
plt.title("Sieve of Eratosthenes runtimes")
plt.xlabel("nMax")
plt.ylabel("time (seconds)");

"""Same thing here there is a positive relation between the run time and range of number of primes being computed.

Lets look at a plot with both methods and compare.
"""

import matplotlib.pyplot as plt
plt.plot(nMaxVals, runtimes, 'r.-', label = "Sieve of eratos runtimes") # creates the plot; syntax is plot(xvals, yvals, format)
plt.title("Runtimes for different Sieve")
plt.plot(nMaxVals1, runtimes1, 'b-',label="Sieve of Sundaram runtimes")
plt.xlabel("nMax")
plt.ylabel("time (seconds)");
plt.legend()

"""Both the methods show a postive correlation between nMax and computing time. We can see that it takes a shorter amount of time to compute for the Sundaram method than it is for Eratosthenes method. Forexample of 2000 the runtime the run time is smaller than 0.005 for Sundaram relative to as high as 0.020 for Eratosthenes.The impact of nMax on computing time is more pronounced in the case of the Sieve of Sundaram, where the computational time increases significantly with higher nMax values.

# Prime project Part 2  

In this project we want to provide computational evidence in support of the conjecture below, or a counterexample that disproves the conjecture.
  

1.   **Conjecture A**. Every even integer greater than 2 is the sum of two primes.
2.   **Conjecture C.** For every positive integer n, there exists at least one prime between n2 and (n + 1)2.
3. **Conjecture D.** All odd numbers greater than 1 are either prime, or can be expressed as the sum of a prime and twice a square.

**Conjecture A**. Every even integer greater than 2 is the sum of two primes.


Let us create a function that takes in a number of iteration. It calls our fasteratos function to check numbers that are prime, a fucntion from earlier (this genreates prime numbers up to n). We want to iterate through pairs of prime numbers to check if their sum is present in the list of even numbers.
"""

def even_numbers(n):
    primelist = fastEratos(n)
    for x in range(4, n + 1, 2):
        found = False
        for i in range(1, len(primelist)):  # Start from index 1 to skip 2
            for k in range(i, len(primelist)):
                if x == primelist[i] + primelist[k]:
                    print("Even number", x, "is the sum of primes:", primelist[i], "and", primelist[k])
                    found = True
                    break
            if found:
                break

even_numbers(20)

"""We can see which two primes add up to any even number. It demonstrates the two primes that add up to certain even numbers. Let us tun it through thousands of even numbers  and have Python report the number of even numbers."""

def even_numbers_conjecture(n):
    primelist = fastEratos(n)
    true_count = 0
    false_count = 0
    total_even_numbers = (n - 2) // 2  # Count of even numbers from 2 to n
    for x in range(4, n + 1, 2):
        found = False
        for i in range(1, len(primelist)):  # Start from index 1 to skip 2
            for k in range(i, len(primelist)):
                if x == primelist[i] + primelist[k]:
                    found = True
                    break
            if found:
                break
        if found:
            true_count += 1
        else:
            false_count += 1
    return true_count, false_count, total_even_numbers

even_numbers_conjecture(1000)

"""Our output shows us the number of even numbers that have the sum of two primes, not even and then the number of even numbers in the total range of iteration. We can see that for 1000 list of primes we have 498 even numbers that are the sum of two primes.

**Conjecture C.** For every positive integer n, there exists at least one prime between $n^2$ and $(n + 1)^2$.

To see a prime number that falls within the range of  $n^2$  and $(n+1)^2$ we start by setting up our upper and lower limit. We reuse our fasteratos function and then create a list for our upper and lower range. After printing out  $n^2$ and $(n + 1)^2$ we use a for loop for every single value in the list.If a value in the list is a prime number then the conjecture is true, if not false.
"""

def in_between_(n):
  lower = n**2
  upper = (n+1)**2
  primes = fastEratos(upper)
  for i in range(lower+1,upper):
    if i in primes:
      return True
  return False

in_between_(1000)

def check_inbetween(n):
  return all(in_between_(i) for i in range (1,n))

print(check_inbetween(50))
print(check_inbetween(100))
print(check_inbetween(500))
print(check_inbetween(1000))

"""We checked values of n from 1 through 1000, and from our output it shows that there seems to be atleast one prime number within this range.

Conjecture D. All odd numbers greater than 1 are either prime, or can be expressed as the sum of a prime and twice a square.
"""

def odd(n):
  primelist = fastEratos(n) #creates list of primes
  for p in range(3,n+1,2): #odd values starting from three to n integers
    value = False
    if p in primelist: #if prime check the next odd integer
      value = True
    elif value == False: #if not prime then check if p is sum of a prime or twice a square.
      for i in range(len(primelist)):
        for j in range(1,int((n/2)**0.5)):#limit endpoint to (n/2)-root as that is the max twice its sqaure can equal n
          if p == primelist[i] + 2*(j**2):
            value = True
            break
        if value == True:
            break
    if value == False: #if odd integer p is not a prime or a sum of a prime and twice a square, the output False and that integer p
      return False, p

  #returns True only if all odd integers from 3 to n integer are either a prime or a sum of prime and twice a square
  return value

odd(10000)

"""For the first 10,000 integers 5777 proves the conjecture D is false becuase it's not a prime, sum of two primes or twice a square. Let us check each conditions:"""

def counter_example(num):
    primes = fastEratos(num)
    for num in range(56):
     for prime in primes[:750]:
       if prime+(2*num**2)==5777:
         print("True")
    print("False")

counter_example(5777)



"""This is the counter example to the cojecture. Our code checks if 5777 falls as a prime or twice of a square."""